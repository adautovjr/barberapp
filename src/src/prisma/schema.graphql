# -----------------------------------------------
# !!! THIS FILE WAS GENERATED BY TYPE-GRAPHQL !!!
# !!!   DO NOT MODIFY THIS FILE BY YOURSELF   !!!
# -----------------------------------------------

type AffectedRowsOutput {
  count: Int!
}

type AggregateRequest {
  _avg: RequestAvgAggregate
  _count: RequestCountAggregate
  _max: RequestMaxAggregate
  _min: RequestMinAggregate
  _sum: RequestSumAggregate
}

type AggregateService {
  _avg: ServiceAvgAggregate
  _count: ServiceCountAggregate
  _max: ServiceMaxAggregate
  _min: ServiceMinAggregate
  _sum: ServiceSumAggregate
}

type AggregateToken {
  _count: TokenCountAggregate
  _max: TokenMaxAggregate
  _min: TokenMinAggregate
}

type AggregateUser {
  _count: UserCountAggregate
  _max: UserMaxAggregate
  _min: UserMinAggregate
}

"""
The javascript `Date` as string. Type represents date and time as the ISO Date string.
"""
scalar DateTime

input DateTimeFieldUpdateOperationsInput {
  set: DateTime
}

input DateTimeFilter {
  equals: DateTime
  gt: DateTime
  gte: DateTime
  in: [DateTime!]
  lt: DateTime
  lte: DateTime
  not: NestedDateTimeFilter
  notIn: [DateTime!]
}

input DateTimeWithAggregatesFilter {
  _count: NestedIntFilter
  _max: NestedDateTimeFilter
  _min: NestedDateTimeFilter
  equals: DateTime
  gt: DateTime
  gte: DateTime
  in: [DateTime!]
  lt: DateTime
  lte: DateTime
  not: NestedDateTimeWithAggregatesFilter
  notIn: [DateTime!]
}

"""
GraphQL Scalar representing the Prisma.Decimal type, based on Decimal.js library.
"""
scalar Decimal

input DecimalFieldUpdateOperationsInput {
  decrement: Decimal
  divide: Decimal
  increment: Decimal
  multiply: Decimal
  set: Decimal
}

input DecimalFilter {
  equals: Decimal
  gt: Decimal
  gte: Decimal
  in: [Decimal!]
  lt: Decimal
  lte: Decimal
  not: NestedDecimalFilter
  notIn: [Decimal!]
}

input DecimalWithAggregatesFilter {
  _avg: NestedDecimalFilter
  _count: NestedIntFilter
  _max: NestedDecimalFilter
  _min: NestedDecimalFilter
  _sum: NestedDecimalFilter
  equals: Decimal
  gt: Decimal
  gte: Decimal
  in: [Decimal!]
  lt: Decimal
  lte: Decimal
  not: NestedDecimalWithAggregatesFilter
  notIn: [Decimal!]
}

input EnumRoleFieldUpdateOperationsInput {
  set: Role
}

input EnumRoleFilter {
  equals: Role
  in: [Role!]
  not: NestedEnumRoleFilter
  notIn: [Role!]
}

input EnumRoleWithAggregatesFilter {
  _count: NestedIntFilter
  _max: NestedEnumRoleFilter
  _min: NestedEnumRoleFilter
  equals: Role
  in: [Role!]
  not: NestedEnumRoleWithAggregatesFilter
  notIn: [Role!]
}

input IntFieldUpdateOperationsInput {
  decrement: Int
  divide: Int
  increment: Int
  multiply: Int
  set: Int
}

input IntFilter {
  equals: Int
  gt: Int
  gte: Int
  in: [Int!]
  lt: Int
  lte: Int
  not: NestedIntFilter
  notIn: [Int!]
}

input IntWithAggregatesFilter {
  _avg: NestedFloatFilter
  _count: NestedIntFilter
  _max: NestedIntFilter
  _min: NestedIntFilter
  _sum: NestedIntFilter
  equals: Int
  gt: Int
  gte: Int
  in: [Int!]
  lt: Int
  lte: Int
  not: NestedIntWithAggregatesFilter
  notIn: [Int!]
}

type Mutation {
  createManyRequest(data: [RequestCreateManyInput!]!, skipDuplicates: Boolean): AffectedRowsOutput!
  createManyService(data: [ServiceCreateManyInput!]!, skipDuplicates: Boolean): AffectedRowsOutput!
  createManyToken(data: [TokenCreateManyInput!]!, skipDuplicates: Boolean): AffectedRowsOutput!
  createManyUser(data: [UserCreateManyInput!]!, skipDuplicates: Boolean): AffectedRowsOutput!
  createRequest(data: RequestCreateInput!): Request!
  createService(data: ServiceCreateInput!): Service!
  createToken(data: TokenCreateInput!): Token!
  createUser(data: UserCreateInput!): User!
  deleteManyRequest(where: RequestWhereInput): AffectedRowsOutput!
  deleteManyService(where: ServiceWhereInput): AffectedRowsOutput!
  deleteManyToken(where: TokenWhereInput): AffectedRowsOutput!
  deleteManyUser(where: UserWhereInput): AffectedRowsOutput!
  deleteRequest(where: RequestWhereUniqueInput!): Request
  deleteService(where: ServiceWhereUniqueInput!): Service
  deleteToken(where: TokenWhereUniqueInput!): Token
  deleteUser(where: UserWhereUniqueInput!): User
  updateManyRequest(data: RequestUpdateManyMutationInput!, where: RequestWhereInput): AffectedRowsOutput!
  updateManyService(data: ServiceUpdateManyMutationInput!, where: ServiceWhereInput): AffectedRowsOutput!
  updateManyToken(data: TokenUpdateManyMutationInput!, where: TokenWhereInput): AffectedRowsOutput!
  updateManyUser(data: UserUpdateManyMutationInput!, where: UserWhereInput): AffectedRowsOutput!
  updateRequest(data: RequestUpdateInput!, where: RequestWhereUniqueInput!): Request
  updateService(data: ServiceUpdateInput!, where: ServiceWhereUniqueInput!): Service
  updateToken(data: TokenUpdateInput!, where: TokenWhereUniqueInput!): Token
  updateUser(data: UserUpdateInput!, where: UserWhereUniqueInput!): User
  upsertRequest(create: RequestCreateInput!, update: RequestUpdateInput!, where: RequestWhereUniqueInput!): Request!
  upsertService(create: ServiceCreateInput!, update: ServiceUpdateInput!, where: ServiceWhereUniqueInput!): Service!
  upsertToken(create: TokenCreateInput!, update: TokenUpdateInput!, where: TokenWhereUniqueInput!): Token!
  upsertUser(create: UserCreateInput!, update: UserUpdateInput!, where: UserWhereUniqueInput!): User!
}

input NestedDateTimeFilter {
  equals: DateTime
  gt: DateTime
  gte: DateTime
  in: [DateTime!]
  lt: DateTime
  lte: DateTime
  not: NestedDateTimeFilter
  notIn: [DateTime!]
}

input NestedDateTimeWithAggregatesFilter {
  _count: NestedIntFilter
  _max: NestedDateTimeFilter
  _min: NestedDateTimeFilter
  equals: DateTime
  gt: DateTime
  gte: DateTime
  in: [DateTime!]
  lt: DateTime
  lte: DateTime
  not: NestedDateTimeWithAggregatesFilter
  notIn: [DateTime!]
}

input NestedDecimalFilter {
  equals: Decimal
  gt: Decimal
  gte: Decimal
  in: [Decimal!]
  lt: Decimal
  lte: Decimal
  not: NestedDecimalFilter
  notIn: [Decimal!]
}

input NestedDecimalWithAggregatesFilter {
  _avg: NestedDecimalFilter
  _count: NestedIntFilter
  _max: NestedDecimalFilter
  _min: NestedDecimalFilter
  _sum: NestedDecimalFilter
  equals: Decimal
  gt: Decimal
  gte: Decimal
  in: [Decimal!]
  lt: Decimal
  lte: Decimal
  not: NestedDecimalWithAggregatesFilter
  notIn: [Decimal!]
}

input NestedEnumRoleFilter {
  equals: Role
  in: [Role!]
  not: NestedEnumRoleFilter
  notIn: [Role!]
}

input NestedEnumRoleWithAggregatesFilter {
  _count: NestedIntFilter
  _max: NestedEnumRoleFilter
  _min: NestedEnumRoleFilter
  equals: Role
  in: [Role!]
  not: NestedEnumRoleWithAggregatesFilter
  notIn: [Role!]
}

input NestedFloatFilter {
  equals: Float
  gt: Float
  gte: Float
  in: [Float!]
  lt: Float
  lte: Float
  not: NestedFloatFilter
  notIn: [Float!]
}

input NestedIntFilter {
  equals: Int
  gt: Int
  gte: Int
  in: [Int!]
  lt: Int
  lte: Int
  not: NestedIntFilter
  notIn: [Int!]
}

input NestedIntNullableFilter {
  equals: Int
  gt: Int
  gte: Int
  in: [Int!]
  lt: Int
  lte: Int
  not: NestedIntNullableFilter
  notIn: [Int!]
}

input NestedIntWithAggregatesFilter {
  _avg: NestedFloatFilter
  _count: NestedIntFilter
  _max: NestedIntFilter
  _min: NestedIntFilter
  _sum: NestedIntFilter
  equals: Int
  gt: Int
  gte: Int
  in: [Int!]
  lt: Int
  lte: Int
  not: NestedIntWithAggregatesFilter
  notIn: [Int!]
}

input NestedStringFilter {
  contains: String
  endsWith: String
  equals: String
  gt: String
  gte: String
  in: [String!]
  lt: String
  lte: String
  not: NestedStringFilter
  notIn: [String!]
  startsWith: String
}

input NestedStringNullableFilter {
  contains: String
  endsWith: String
  equals: String
  gt: String
  gte: String
  in: [String!]
  lt: String
  lte: String
  not: NestedStringNullableFilter
  notIn: [String!]
  startsWith: String
}

input NestedStringNullableWithAggregatesFilter {
  _count: NestedIntNullableFilter
  _max: NestedStringNullableFilter
  _min: NestedStringNullableFilter
  contains: String
  endsWith: String
  equals: String
  gt: String
  gte: String
  in: [String!]
  lt: String
  lte: String
  not: NestedStringNullableWithAggregatesFilter
  notIn: [String!]
  startsWith: String
}

input NestedStringWithAggregatesFilter {
  _count: NestedIntFilter
  _max: NestedStringFilter
  _min: NestedStringFilter
  contains: String
  endsWith: String
  equals: String
  gt: String
  gte: String
  in: [String!]
  lt: String
  lte: String
  not: NestedStringWithAggregatesFilter
  notIn: [String!]
  startsWith: String
}

input NullableStringFieldUpdateOperationsInput {
  set: String
}

type Query {
  aggregateRequest(cursor: RequestWhereUniqueInput, orderBy: [RequestOrderByWithRelationInput!], skip: Int, take: Int, where: RequestWhereInput): AggregateRequest!
  aggregateService(cursor: ServiceWhereUniqueInput, orderBy: [ServiceOrderByWithRelationInput!], skip: Int, take: Int, where: ServiceWhereInput): AggregateService!
  aggregateToken(cursor: TokenWhereUniqueInput, orderBy: [TokenOrderByWithRelationInput!], skip: Int, take: Int, where: TokenWhereInput): AggregateToken!
  aggregateUser(cursor: UserWhereUniqueInput, orderBy: [UserOrderByWithRelationInput!], skip: Int, take: Int, where: UserWhereInput): AggregateUser!
  findFirstRequest(cursor: RequestWhereUniqueInput, distinct: [RequestScalarFieldEnum!], orderBy: [RequestOrderByWithRelationInput!], skip: Int, take: Int, where: RequestWhereInput): Request
  findFirstService(cursor: ServiceWhereUniqueInput, distinct: [ServiceScalarFieldEnum!], orderBy: [ServiceOrderByWithRelationInput!], skip: Int, take: Int, where: ServiceWhereInput): Service
  findFirstToken(cursor: TokenWhereUniqueInput, distinct: [TokenScalarFieldEnum!], orderBy: [TokenOrderByWithRelationInput!], skip: Int, take: Int, where: TokenWhereInput): Token
  findFirstUser(cursor: UserWhereUniqueInput, distinct: [UserScalarFieldEnum!], orderBy: [UserOrderByWithRelationInput!], skip: Int, take: Int, where: UserWhereInput): User
  groupByRequest(by: [RequestScalarFieldEnum!]!, having: RequestScalarWhereWithAggregatesInput, orderBy: [RequestOrderByWithAggregationInput!], skip: Int, take: Int, where: RequestWhereInput): [RequestGroupBy!]!
  groupByService(by: [ServiceScalarFieldEnum!]!, having: ServiceScalarWhereWithAggregatesInput, orderBy: [ServiceOrderByWithAggregationInput!], skip: Int, take: Int, where: ServiceWhereInput): [ServiceGroupBy!]!
  groupByToken(by: [TokenScalarFieldEnum!]!, having: TokenScalarWhereWithAggregatesInput, orderBy: [TokenOrderByWithAggregationInput!], skip: Int, take: Int, where: TokenWhereInput): [TokenGroupBy!]!
  groupByUser(by: [UserScalarFieldEnum!]!, having: UserScalarWhereWithAggregatesInput, orderBy: [UserOrderByWithAggregationInput!], skip: Int, take: Int, where: UserWhereInput): [UserGroupBy!]!
  request(where: RequestWhereUniqueInput!): Request
  requests(cursor: RequestWhereUniqueInput, distinct: [RequestScalarFieldEnum!], orderBy: [RequestOrderByWithRelationInput!], skip: Int, take: Int, where: RequestWhereInput): [Request!]!
  service(where: ServiceWhereUniqueInput!): Service
  services(cursor: ServiceWhereUniqueInput, distinct: [ServiceScalarFieldEnum!], orderBy: [ServiceOrderByWithRelationInput!], skip: Int, take: Int, where: ServiceWhereInput): [Service!]!
  token(where: TokenWhereUniqueInput!): Token
  tokens(cursor: TokenWhereUniqueInput, distinct: [TokenScalarFieldEnum!], orderBy: [TokenOrderByWithRelationInput!], skip: Int, take: Int, where: TokenWhereInput): [Token!]!
  user(where: UserWhereUniqueInput!): User
  users(cursor: UserWhereUniqueInput, distinct: [UserScalarFieldEnum!], orderBy: [UserOrderByWithRelationInput!], skip: Int, take: Int, where: UserWhereInput): [User!]!
}

enum QueryMode {
  default
  insensitive
}

type Request {
  barber: User!
  barberId: String!
  client: User!
  clientId: String!
  createdAt: DateTime!
  date: DateTime!
  id: String!
  price: Decimal!
  service: Service!
  serviceId: String!
  updatedAt: DateTime!
}

type RequestAvgAggregate {
  price: Decimal
}

input RequestAvgOrderByAggregateInput {
  price: SortOrder
}

type RequestCountAggregate {
  _all: Int!
  barberId: Int!
  clientId: Int!
  createdAt: Int!
  date: Int!
  id: Int!
  price: Int!
  serviceId: Int!
  updatedAt: Int!
}

input RequestCountOrderByAggregateInput {
  barberId: SortOrder
  clientId: SortOrder
  createdAt: SortOrder
  date: SortOrder
  id: SortOrder
  price: SortOrder
  serviceId: SortOrder
  updatedAt: SortOrder
}

input RequestCreateInput {
  barber: UserCreateNestedOneWithoutRequestsAsBarberInput!
  client: UserCreateNestedOneWithoutRequestsAsClientInput!
  createdAt: DateTime
  date: DateTime!
  id: String
  price: Decimal!
  service: ServiceCreateNestedOneWithoutRequestsInput!
  updatedAt: DateTime
}

input RequestCreateManyBarberInput {
  clientId: String!
  createdAt: DateTime
  date: DateTime!
  id: String
  price: Decimal!
  serviceId: String!
  updatedAt: DateTime
}

input RequestCreateManyBarberInputEnvelope {
  data: [RequestCreateManyBarberInput!]!
  skipDuplicates: Boolean
}

input RequestCreateManyClientInput {
  barberId: String!
  createdAt: DateTime
  date: DateTime!
  id: String
  price: Decimal!
  serviceId: String!
  updatedAt: DateTime
}

input RequestCreateManyClientInputEnvelope {
  data: [RequestCreateManyClientInput!]!
  skipDuplicates: Boolean
}

input RequestCreateManyInput {
  barberId: String!
  clientId: String!
  createdAt: DateTime
  date: DateTime!
  id: String
  price: Decimal!
  serviceId: String!
  updatedAt: DateTime
}

input RequestCreateManyServiceInput {
  barberId: String!
  clientId: String!
  createdAt: DateTime
  date: DateTime!
  id: String
  price: Decimal!
  updatedAt: DateTime
}

input RequestCreateManyServiceInputEnvelope {
  data: [RequestCreateManyServiceInput!]!
  skipDuplicates: Boolean
}

input RequestCreateNestedManyWithoutBarberInput {
  connect: [RequestWhereUniqueInput!]
  connectOrCreate: [RequestCreateOrConnectWithoutBarberInput!]
  create: [RequestCreateWithoutBarberInput!]
  createMany: RequestCreateManyBarberInputEnvelope
}

input RequestCreateNestedManyWithoutClientInput {
  connect: [RequestWhereUniqueInput!]
  connectOrCreate: [RequestCreateOrConnectWithoutClientInput!]
  create: [RequestCreateWithoutClientInput!]
  createMany: RequestCreateManyClientInputEnvelope
}

input RequestCreateNestedManyWithoutServiceInput {
  connect: [RequestWhereUniqueInput!]
  connectOrCreate: [RequestCreateOrConnectWithoutServiceInput!]
  create: [RequestCreateWithoutServiceInput!]
  createMany: RequestCreateManyServiceInputEnvelope
}

input RequestCreateOrConnectWithoutBarberInput {
  create: RequestCreateWithoutBarberInput!
  where: RequestWhereUniqueInput!
}

input RequestCreateOrConnectWithoutClientInput {
  create: RequestCreateWithoutClientInput!
  where: RequestWhereUniqueInput!
}

input RequestCreateOrConnectWithoutServiceInput {
  create: RequestCreateWithoutServiceInput!
  where: RequestWhereUniqueInput!
}

input RequestCreateWithoutBarberInput {
  client: UserCreateNestedOneWithoutRequestsAsClientInput!
  createdAt: DateTime
  date: DateTime!
  id: String
  price: Decimal!
  service: ServiceCreateNestedOneWithoutRequestsInput!
  updatedAt: DateTime
}

input RequestCreateWithoutClientInput {
  barber: UserCreateNestedOneWithoutRequestsAsBarberInput!
  createdAt: DateTime
  date: DateTime!
  id: String
  price: Decimal!
  service: ServiceCreateNestedOneWithoutRequestsInput!
  updatedAt: DateTime
}

input RequestCreateWithoutServiceInput {
  barber: UserCreateNestedOneWithoutRequestsAsBarberInput!
  client: UserCreateNestedOneWithoutRequestsAsClientInput!
  createdAt: DateTime
  date: DateTime!
  id: String
  price: Decimal!
  updatedAt: DateTime
}

type RequestGroupBy {
  _avg: RequestAvgAggregate
  _count: RequestCountAggregate
  _max: RequestMaxAggregate
  _min: RequestMinAggregate
  _sum: RequestSumAggregate
  barberId: String!
  clientId: String!
  createdAt: DateTime!
  date: DateTime!
  id: String!
  price: Decimal!
  serviceId: String!
  updatedAt: DateTime!
}

input RequestListRelationFilter {
  every: RequestWhereInput
  none: RequestWhereInput
  some: RequestWhereInput
}

type RequestMaxAggregate {
  barberId: String
  clientId: String
  createdAt: DateTime
  date: DateTime
  id: String
  price: Decimal
  serviceId: String
  updatedAt: DateTime
}

input RequestMaxOrderByAggregateInput {
  barberId: SortOrder
  clientId: SortOrder
  createdAt: SortOrder
  date: SortOrder
  id: SortOrder
  price: SortOrder
  serviceId: SortOrder
  updatedAt: SortOrder
}

type RequestMinAggregate {
  barberId: String
  clientId: String
  createdAt: DateTime
  date: DateTime
  id: String
  price: Decimal
  serviceId: String
  updatedAt: DateTime
}

input RequestMinOrderByAggregateInput {
  barberId: SortOrder
  clientId: SortOrder
  createdAt: SortOrder
  date: SortOrder
  id: SortOrder
  price: SortOrder
  serviceId: SortOrder
  updatedAt: SortOrder
}

input RequestOrderByRelationAggregateInput {
  _count: SortOrder
}

input RequestOrderByWithAggregationInput {
  _avg: RequestAvgOrderByAggregateInput
  _count: RequestCountOrderByAggregateInput
  _max: RequestMaxOrderByAggregateInput
  _min: RequestMinOrderByAggregateInput
  _sum: RequestSumOrderByAggregateInput
  barberId: SortOrder
  clientId: SortOrder
  createdAt: SortOrder
  date: SortOrder
  id: SortOrder
  price: SortOrder
  serviceId: SortOrder
  updatedAt: SortOrder
}

input RequestOrderByWithRelationInput {
  barber: UserOrderByWithRelationInput
  barberId: SortOrder
  client: UserOrderByWithRelationInput
  clientId: SortOrder
  createdAt: SortOrder
  date: SortOrder
  id: SortOrder
  price: SortOrder
  service: ServiceOrderByWithRelationInput
  serviceId: SortOrder
  updatedAt: SortOrder
}

enum RequestScalarFieldEnum {
  barberId
  clientId
  createdAt
  date
  id
  price
  serviceId
  updatedAt
}

input RequestScalarWhereInput {
  AND: [RequestScalarWhereInput!]
  NOT: [RequestScalarWhereInput!]
  OR: [RequestScalarWhereInput!]
  barberId: StringFilter
  clientId: StringFilter
  createdAt: DateTimeFilter
  date: DateTimeFilter
  id: StringFilter
  price: DecimalFilter
  serviceId: StringFilter
  updatedAt: DateTimeFilter
}

input RequestScalarWhereWithAggregatesInput {
  AND: [RequestScalarWhereWithAggregatesInput!]
  NOT: [RequestScalarWhereWithAggregatesInput!]
  OR: [RequestScalarWhereWithAggregatesInput!]
  barberId: StringWithAggregatesFilter
  clientId: StringWithAggregatesFilter
  createdAt: DateTimeWithAggregatesFilter
  date: DateTimeWithAggregatesFilter
  id: StringWithAggregatesFilter
  price: DecimalWithAggregatesFilter
  serviceId: StringWithAggregatesFilter
  updatedAt: DateTimeWithAggregatesFilter
}

type RequestSumAggregate {
  price: Decimal
}

input RequestSumOrderByAggregateInput {
  price: SortOrder
}

input RequestUpdateInput {
  barber: UserUpdateOneRequiredWithoutRequestsAsBarberInput
  client: UserUpdateOneRequiredWithoutRequestsAsClientInput
  createdAt: DateTimeFieldUpdateOperationsInput
  date: DateTimeFieldUpdateOperationsInput
  id: StringFieldUpdateOperationsInput
  price: DecimalFieldUpdateOperationsInput
  service: ServiceUpdateOneRequiredWithoutRequestsInput
  updatedAt: DateTimeFieldUpdateOperationsInput
}

input RequestUpdateManyMutationInput {
  createdAt: DateTimeFieldUpdateOperationsInput
  date: DateTimeFieldUpdateOperationsInput
  id: StringFieldUpdateOperationsInput
  price: DecimalFieldUpdateOperationsInput
  updatedAt: DateTimeFieldUpdateOperationsInput
}

input RequestUpdateManyWithWhereWithoutBarberInput {
  data: RequestUpdateManyMutationInput!
  where: RequestScalarWhereInput!
}

input RequestUpdateManyWithWhereWithoutClientInput {
  data: RequestUpdateManyMutationInput!
  where: RequestScalarWhereInput!
}

input RequestUpdateManyWithWhereWithoutServiceInput {
  data: RequestUpdateManyMutationInput!
  where: RequestScalarWhereInput!
}

input RequestUpdateManyWithoutBarberInput {
  connect: [RequestWhereUniqueInput!]
  connectOrCreate: [RequestCreateOrConnectWithoutBarberInput!]
  create: [RequestCreateWithoutBarberInput!]
  createMany: RequestCreateManyBarberInputEnvelope
  delete: [RequestWhereUniqueInput!]
  deleteMany: [RequestScalarWhereInput!]
  disconnect: [RequestWhereUniqueInput!]
  set: [RequestWhereUniqueInput!]
  update: [RequestUpdateWithWhereUniqueWithoutBarberInput!]
  updateMany: [RequestUpdateManyWithWhereWithoutBarberInput!]
  upsert: [RequestUpsertWithWhereUniqueWithoutBarberInput!]
}

input RequestUpdateManyWithoutClientInput {
  connect: [RequestWhereUniqueInput!]
  connectOrCreate: [RequestCreateOrConnectWithoutClientInput!]
  create: [RequestCreateWithoutClientInput!]
  createMany: RequestCreateManyClientInputEnvelope
  delete: [RequestWhereUniqueInput!]
  deleteMany: [RequestScalarWhereInput!]
  disconnect: [RequestWhereUniqueInput!]
  set: [RequestWhereUniqueInput!]
  update: [RequestUpdateWithWhereUniqueWithoutClientInput!]
  updateMany: [RequestUpdateManyWithWhereWithoutClientInput!]
  upsert: [RequestUpsertWithWhereUniqueWithoutClientInput!]
}

input RequestUpdateManyWithoutServiceInput {
  connect: [RequestWhereUniqueInput!]
  connectOrCreate: [RequestCreateOrConnectWithoutServiceInput!]
  create: [RequestCreateWithoutServiceInput!]
  createMany: RequestCreateManyServiceInputEnvelope
  delete: [RequestWhereUniqueInput!]
  deleteMany: [RequestScalarWhereInput!]
  disconnect: [RequestWhereUniqueInput!]
  set: [RequestWhereUniqueInput!]
  update: [RequestUpdateWithWhereUniqueWithoutServiceInput!]
  updateMany: [RequestUpdateManyWithWhereWithoutServiceInput!]
  upsert: [RequestUpsertWithWhereUniqueWithoutServiceInput!]
}

input RequestUpdateWithWhereUniqueWithoutBarberInput {
  data: RequestUpdateWithoutBarberInput!
  where: RequestWhereUniqueInput!
}

input RequestUpdateWithWhereUniqueWithoutClientInput {
  data: RequestUpdateWithoutClientInput!
  where: RequestWhereUniqueInput!
}

input RequestUpdateWithWhereUniqueWithoutServiceInput {
  data: RequestUpdateWithoutServiceInput!
  where: RequestWhereUniqueInput!
}

input RequestUpdateWithoutBarberInput {
  client: UserUpdateOneRequiredWithoutRequestsAsClientInput
  createdAt: DateTimeFieldUpdateOperationsInput
  date: DateTimeFieldUpdateOperationsInput
  id: StringFieldUpdateOperationsInput
  price: DecimalFieldUpdateOperationsInput
  service: ServiceUpdateOneRequiredWithoutRequestsInput
  updatedAt: DateTimeFieldUpdateOperationsInput
}

input RequestUpdateWithoutClientInput {
  barber: UserUpdateOneRequiredWithoutRequestsAsBarberInput
  createdAt: DateTimeFieldUpdateOperationsInput
  date: DateTimeFieldUpdateOperationsInput
  id: StringFieldUpdateOperationsInput
  price: DecimalFieldUpdateOperationsInput
  service: ServiceUpdateOneRequiredWithoutRequestsInput
  updatedAt: DateTimeFieldUpdateOperationsInput
}

input RequestUpdateWithoutServiceInput {
  barber: UserUpdateOneRequiredWithoutRequestsAsBarberInput
  client: UserUpdateOneRequiredWithoutRequestsAsClientInput
  createdAt: DateTimeFieldUpdateOperationsInput
  date: DateTimeFieldUpdateOperationsInput
  id: StringFieldUpdateOperationsInput
  price: DecimalFieldUpdateOperationsInput
  updatedAt: DateTimeFieldUpdateOperationsInput
}

input RequestUpsertWithWhereUniqueWithoutBarberInput {
  create: RequestCreateWithoutBarberInput!
  update: RequestUpdateWithoutBarberInput!
  where: RequestWhereUniqueInput!
}

input RequestUpsertWithWhereUniqueWithoutClientInput {
  create: RequestCreateWithoutClientInput!
  update: RequestUpdateWithoutClientInput!
  where: RequestWhereUniqueInput!
}

input RequestUpsertWithWhereUniqueWithoutServiceInput {
  create: RequestCreateWithoutServiceInput!
  update: RequestUpdateWithoutServiceInput!
  where: RequestWhereUniqueInput!
}

input RequestWhereInput {
  AND: [RequestWhereInput!]
  NOT: [RequestWhereInput!]
  OR: [RequestWhereInput!]
  barber: UserRelationFilter
  barberId: StringFilter
  client: UserRelationFilter
  clientId: StringFilter
  createdAt: DateTimeFilter
  date: DateTimeFilter
  id: StringFilter
  price: DecimalFilter
  service: ServiceRelationFilter
  serviceId: StringFilter
  updatedAt: DateTimeFilter
}

input RequestWhereUniqueInput {
  id: String
}

enum Role {
  ADMIN
  BARBER
  GUEST
}

type Service {
  _count: ServiceCount
  barbers(cursor: UserWhereUniqueInput, distinct: [UserScalarFieldEnum!], orderBy: [UserOrderByWithRelationInput!], skip: Int, take: Int, where: UserWhereInput): [User!]!
  createdAt: DateTime!
  duration: Int!
  id: String!
  name: String!
  price: Decimal!
  requests(cursor: RequestWhereUniqueInput, distinct: [RequestScalarFieldEnum!], orderBy: [RequestOrderByWithRelationInput!], skip: Int, take: Int, where: RequestWhereInput): [Request!]!
  updatedAt: DateTime!
}

type ServiceAvgAggregate {
  duration: Float
  price: Decimal
}

input ServiceAvgOrderByAggregateInput {
  duration: SortOrder
  price: SortOrder
}

type ServiceCount {
  barbers: Int!
  requests: Int!
}

type ServiceCountAggregate {
  _all: Int!
  createdAt: Int!
  duration: Int!
  id: Int!
  name: Int!
  price: Int!
  updatedAt: Int!
}

input ServiceCountOrderByAggregateInput {
  createdAt: SortOrder
  duration: SortOrder
  id: SortOrder
  name: SortOrder
  price: SortOrder
  updatedAt: SortOrder
}

input ServiceCreateInput {
  barbers: UserCreateNestedManyWithoutServicesInput
  createdAt: DateTime
  duration: Int!
  id: String
  name: String!
  price: Decimal!
  requests: RequestCreateNestedManyWithoutServiceInput
  updatedAt: DateTime
}

input ServiceCreateManyInput {
  createdAt: DateTime
  duration: Int!
  id: String
  name: String!
  price: Decimal!
  updatedAt: DateTime
}

input ServiceCreateNestedManyWithoutBarbersInput {
  connect: [ServiceWhereUniqueInput!]
  connectOrCreate: [ServiceCreateOrConnectWithoutBarbersInput!]
  create: [ServiceCreateWithoutBarbersInput!]
}

input ServiceCreateNestedOneWithoutRequestsInput {
  connect: ServiceWhereUniqueInput
  connectOrCreate: ServiceCreateOrConnectWithoutRequestsInput
  create: ServiceCreateWithoutRequestsInput
}

input ServiceCreateOrConnectWithoutBarbersInput {
  create: ServiceCreateWithoutBarbersInput!
  where: ServiceWhereUniqueInput!
}

input ServiceCreateOrConnectWithoutRequestsInput {
  create: ServiceCreateWithoutRequestsInput!
  where: ServiceWhereUniqueInput!
}

input ServiceCreateWithoutBarbersInput {
  createdAt: DateTime
  duration: Int!
  id: String
  name: String!
  price: Decimal!
  requests: RequestCreateNestedManyWithoutServiceInput
  updatedAt: DateTime
}

input ServiceCreateWithoutRequestsInput {
  barbers: UserCreateNestedManyWithoutServicesInput
  createdAt: DateTime
  duration: Int!
  id: String
  name: String!
  price: Decimal!
  updatedAt: DateTime
}

type ServiceGroupBy {
  _avg: ServiceAvgAggregate
  _count: ServiceCountAggregate
  _max: ServiceMaxAggregate
  _min: ServiceMinAggregate
  _sum: ServiceSumAggregate
  createdAt: DateTime!
  duration: Int!
  id: String!
  name: String!
  price: Decimal!
  updatedAt: DateTime!
}

input ServiceListRelationFilter {
  every: ServiceWhereInput
  none: ServiceWhereInput
  some: ServiceWhereInput
}

type ServiceMaxAggregate {
  createdAt: DateTime
  duration: Int
  id: String
  name: String
  price: Decimal
  updatedAt: DateTime
}

input ServiceMaxOrderByAggregateInput {
  createdAt: SortOrder
  duration: SortOrder
  id: SortOrder
  name: SortOrder
  price: SortOrder
  updatedAt: SortOrder
}

type ServiceMinAggregate {
  createdAt: DateTime
  duration: Int
  id: String
  name: String
  price: Decimal
  updatedAt: DateTime
}

input ServiceMinOrderByAggregateInput {
  createdAt: SortOrder
  duration: SortOrder
  id: SortOrder
  name: SortOrder
  price: SortOrder
  updatedAt: SortOrder
}

input ServiceOrderByRelationAggregateInput {
  _count: SortOrder
}

input ServiceOrderByWithAggregationInput {
  _avg: ServiceAvgOrderByAggregateInput
  _count: ServiceCountOrderByAggregateInput
  _max: ServiceMaxOrderByAggregateInput
  _min: ServiceMinOrderByAggregateInput
  _sum: ServiceSumOrderByAggregateInput
  createdAt: SortOrder
  duration: SortOrder
  id: SortOrder
  name: SortOrder
  price: SortOrder
  updatedAt: SortOrder
}

input ServiceOrderByWithRelationInput {
  barbers: UserOrderByRelationAggregateInput
  createdAt: SortOrder
  duration: SortOrder
  id: SortOrder
  name: SortOrder
  price: SortOrder
  requests: RequestOrderByRelationAggregateInput
  updatedAt: SortOrder
}

input ServiceRelationFilter {
  is: ServiceWhereInput
  isNot: ServiceWhereInput
}

enum ServiceScalarFieldEnum {
  createdAt
  duration
  id
  name
  price
  updatedAt
}

input ServiceScalarWhereInput {
  AND: [ServiceScalarWhereInput!]
  NOT: [ServiceScalarWhereInput!]
  OR: [ServiceScalarWhereInput!]
  createdAt: DateTimeFilter
  duration: IntFilter
  id: StringFilter
  name: StringFilter
  price: DecimalFilter
  updatedAt: DateTimeFilter
}

input ServiceScalarWhereWithAggregatesInput {
  AND: [ServiceScalarWhereWithAggregatesInput!]
  NOT: [ServiceScalarWhereWithAggregatesInput!]
  OR: [ServiceScalarWhereWithAggregatesInput!]
  createdAt: DateTimeWithAggregatesFilter
  duration: IntWithAggregatesFilter
  id: StringWithAggregatesFilter
  name: StringWithAggregatesFilter
  price: DecimalWithAggregatesFilter
  updatedAt: DateTimeWithAggregatesFilter
}

type ServiceSumAggregate {
  duration: Int
  price: Decimal
}

input ServiceSumOrderByAggregateInput {
  duration: SortOrder
  price: SortOrder
}

input ServiceUpdateInput {
  barbers: UserUpdateManyWithoutServicesInput
  createdAt: DateTimeFieldUpdateOperationsInput
  duration: IntFieldUpdateOperationsInput
  id: StringFieldUpdateOperationsInput
  name: StringFieldUpdateOperationsInput
  price: DecimalFieldUpdateOperationsInput
  requests: RequestUpdateManyWithoutServiceInput
  updatedAt: DateTimeFieldUpdateOperationsInput
}

input ServiceUpdateManyMutationInput {
  createdAt: DateTimeFieldUpdateOperationsInput
  duration: IntFieldUpdateOperationsInput
  id: StringFieldUpdateOperationsInput
  name: StringFieldUpdateOperationsInput
  price: DecimalFieldUpdateOperationsInput
  updatedAt: DateTimeFieldUpdateOperationsInput
}

input ServiceUpdateManyWithWhereWithoutBarbersInput {
  data: ServiceUpdateManyMutationInput!
  where: ServiceScalarWhereInput!
}

input ServiceUpdateManyWithoutBarbersInput {
  connect: [ServiceWhereUniqueInput!]
  connectOrCreate: [ServiceCreateOrConnectWithoutBarbersInput!]
  create: [ServiceCreateWithoutBarbersInput!]
  delete: [ServiceWhereUniqueInput!]
  deleteMany: [ServiceScalarWhereInput!]
  disconnect: [ServiceWhereUniqueInput!]
  set: [ServiceWhereUniqueInput!]
  update: [ServiceUpdateWithWhereUniqueWithoutBarbersInput!]
  updateMany: [ServiceUpdateManyWithWhereWithoutBarbersInput!]
  upsert: [ServiceUpsertWithWhereUniqueWithoutBarbersInput!]
}

input ServiceUpdateOneRequiredWithoutRequestsInput {
  connect: ServiceWhereUniqueInput
  connectOrCreate: ServiceCreateOrConnectWithoutRequestsInput
  create: ServiceCreateWithoutRequestsInput
  update: ServiceUpdateWithoutRequestsInput
  upsert: ServiceUpsertWithoutRequestsInput
}

input ServiceUpdateWithWhereUniqueWithoutBarbersInput {
  data: ServiceUpdateWithoutBarbersInput!
  where: ServiceWhereUniqueInput!
}

input ServiceUpdateWithoutBarbersInput {
  createdAt: DateTimeFieldUpdateOperationsInput
  duration: IntFieldUpdateOperationsInput
  id: StringFieldUpdateOperationsInput
  name: StringFieldUpdateOperationsInput
  price: DecimalFieldUpdateOperationsInput
  requests: RequestUpdateManyWithoutServiceInput
  updatedAt: DateTimeFieldUpdateOperationsInput
}

input ServiceUpdateWithoutRequestsInput {
  barbers: UserUpdateManyWithoutServicesInput
  createdAt: DateTimeFieldUpdateOperationsInput
  duration: IntFieldUpdateOperationsInput
  id: StringFieldUpdateOperationsInput
  name: StringFieldUpdateOperationsInput
  price: DecimalFieldUpdateOperationsInput
  updatedAt: DateTimeFieldUpdateOperationsInput
}

input ServiceUpsertWithWhereUniqueWithoutBarbersInput {
  create: ServiceCreateWithoutBarbersInput!
  update: ServiceUpdateWithoutBarbersInput!
  where: ServiceWhereUniqueInput!
}

input ServiceUpsertWithoutRequestsInput {
  create: ServiceCreateWithoutRequestsInput!
  update: ServiceUpdateWithoutRequestsInput!
}

input ServiceWhereInput {
  AND: [ServiceWhereInput!]
  NOT: [ServiceWhereInput!]
  OR: [ServiceWhereInput!]
  barbers: UserListRelationFilter
  createdAt: DateTimeFilter
  duration: IntFilter
  id: StringFilter
  name: StringFilter
  price: DecimalFilter
  requests: RequestListRelationFilter
  updatedAt: DateTimeFilter
}

input ServiceWhereUniqueInput {
  id: String
}

enum SortOrder {
  asc
  desc
}

input StringFieldUpdateOperationsInput {
  set: String
}

input StringFilter {
  contains: String
  endsWith: String
  equals: String
  gt: String
  gte: String
  in: [String!]
  lt: String
  lte: String
  mode: QueryMode
  not: NestedStringFilter
  notIn: [String!]
  startsWith: String
}

input StringNullableFilter {
  contains: String
  endsWith: String
  equals: String
  gt: String
  gte: String
  in: [String!]
  lt: String
  lte: String
  mode: QueryMode
  not: NestedStringNullableFilter
  notIn: [String!]
  startsWith: String
}

input StringNullableWithAggregatesFilter {
  _count: NestedIntNullableFilter
  _max: NestedStringNullableFilter
  _min: NestedStringNullableFilter
  contains: String
  endsWith: String
  equals: String
  gt: String
  gte: String
  in: [String!]
  lt: String
  lte: String
  mode: QueryMode
  not: NestedStringNullableWithAggregatesFilter
  notIn: [String!]
  startsWith: String
}

input StringWithAggregatesFilter {
  _count: NestedIntFilter
  _max: NestedStringFilter
  _min: NestedStringFilter
  contains: String
  endsWith: String
  equals: String
  gt: String
  gte: String
  in: [String!]
  lt: String
  lte: String
  mode: QueryMode
  not: NestedStringWithAggregatesFilter
  notIn: [String!]
  startsWith: String
}

type Token {
  content: String!
  id: String!
  user: User!
  userId: String!
}

type TokenCountAggregate {
  _all: Int!
  content: Int!
  id: Int!
  userId: Int!
}

input TokenCountOrderByAggregateInput {
  content: SortOrder
  id: SortOrder
  userId: SortOrder
}

input TokenCreateInput {
  content: String!
  id: String
  user: UserCreateNestedOneWithoutTokensInput!
}

input TokenCreateManyInput {
  content: String!
  id: String
  userId: String!
}

input TokenCreateManyUserInput {
  content: String!
  id: String
}

input TokenCreateManyUserInputEnvelope {
  data: [TokenCreateManyUserInput!]!
  skipDuplicates: Boolean
}

input TokenCreateNestedManyWithoutUserInput {
  connect: [TokenWhereUniqueInput!]
  connectOrCreate: [TokenCreateOrConnectWithoutUserInput!]
  create: [TokenCreateWithoutUserInput!]
  createMany: TokenCreateManyUserInputEnvelope
}

input TokenCreateOrConnectWithoutUserInput {
  create: TokenCreateWithoutUserInput!
  where: TokenWhereUniqueInput!
}

input TokenCreateWithoutUserInput {
  content: String!
  id: String
}

type TokenGroupBy {
  _count: TokenCountAggregate
  _max: TokenMaxAggregate
  _min: TokenMinAggregate
  content: String!
  id: String!
  userId: String!
}

input TokenListRelationFilter {
  every: TokenWhereInput
  none: TokenWhereInput
  some: TokenWhereInput
}

type TokenMaxAggregate {
  content: String
  id: String
  userId: String
}

input TokenMaxOrderByAggregateInput {
  content: SortOrder
  id: SortOrder
  userId: SortOrder
}

type TokenMinAggregate {
  content: String
  id: String
  userId: String
}

input TokenMinOrderByAggregateInput {
  content: SortOrder
  id: SortOrder
  userId: SortOrder
}

input TokenOrderByRelationAggregateInput {
  _count: SortOrder
}

input TokenOrderByWithAggregationInput {
  _count: TokenCountOrderByAggregateInput
  _max: TokenMaxOrderByAggregateInput
  _min: TokenMinOrderByAggregateInput
  content: SortOrder
  id: SortOrder
  userId: SortOrder
}

input TokenOrderByWithRelationInput {
  content: SortOrder
  id: SortOrder
  user: UserOrderByWithRelationInput
  userId: SortOrder
}

enum TokenScalarFieldEnum {
  content
  id
  userId
}

input TokenScalarWhereInput {
  AND: [TokenScalarWhereInput!]
  NOT: [TokenScalarWhereInput!]
  OR: [TokenScalarWhereInput!]
  content: StringFilter
  id: StringFilter
  userId: StringFilter
}

input TokenScalarWhereWithAggregatesInput {
  AND: [TokenScalarWhereWithAggregatesInput!]
  NOT: [TokenScalarWhereWithAggregatesInput!]
  OR: [TokenScalarWhereWithAggregatesInput!]
  content: StringWithAggregatesFilter
  id: StringWithAggregatesFilter
  userId: StringWithAggregatesFilter
}

input TokenUpdateInput {
  content: StringFieldUpdateOperationsInput
  id: StringFieldUpdateOperationsInput
  user: UserUpdateOneRequiredWithoutTokensInput
}

input TokenUpdateManyMutationInput {
  content: StringFieldUpdateOperationsInput
  id: StringFieldUpdateOperationsInput
}

input TokenUpdateManyWithWhereWithoutUserInput {
  data: TokenUpdateManyMutationInput!
  where: TokenScalarWhereInput!
}

input TokenUpdateManyWithoutUserInput {
  connect: [TokenWhereUniqueInput!]
  connectOrCreate: [TokenCreateOrConnectWithoutUserInput!]
  create: [TokenCreateWithoutUserInput!]
  createMany: TokenCreateManyUserInputEnvelope
  delete: [TokenWhereUniqueInput!]
  deleteMany: [TokenScalarWhereInput!]
  disconnect: [TokenWhereUniqueInput!]
  set: [TokenWhereUniqueInput!]
  update: [TokenUpdateWithWhereUniqueWithoutUserInput!]
  updateMany: [TokenUpdateManyWithWhereWithoutUserInput!]
  upsert: [TokenUpsertWithWhereUniqueWithoutUserInput!]
}

input TokenUpdateWithWhereUniqueWithoutUserInput {
  data: TokenUpdateWithoutUserInput!
  where: TokenWhereUniqueInput!
}

input TokenUpdateWithoutUserInput {
  content: StringFieldUpdateOperationsInput
  id: StringFieldUpdateOperationsInput
}

input TokenUpsertWithWhereUniqueWithoutUserInput {
  create: TokenCreateWithoutUserInput!
  update: TokenUpdateWithoutUserInput!
  where: TokenWhereUniqueInput!
}

input TokenWhereInput {
  AND: [TokenWhereInput!]
  NOT: [TokenWhereInput!]
  OR: [TokenWhereInput!]
  content: StringFilter
  id: StringFilter
  user: UserRelationFilter
  userId: StringFilter
}

input TokenWhereUniqueInput {
  content: String
  id: String
}

type User {
  _count: UserCount
  createdAt: DateTime!
  email: String
  id: String!
  name: String!
  phone: String
  requestsAsBarber(cursor: RequestWhereUniqueInput, distinct: [RequestScalarFieldEnum!], orderBy: [RequestOrderByWithRelationInput!], skip: Int, take: Int, where: RequestWhereInput): [Request!]!
  requestsAsClient(cursor: RequestWhereUniqueInput, distinct: [RequestScalarFieldEnum!], orderBy: [RequestOrderByWithRelationInput!], skip: Int, take: Int, where: RequestWhereInput): [Request!]!
  role: Role!
  services(cursor: ServiceWhereUniqueInput, distinct: [ServiceScalarFieldEnum!], orderBy: [ServiceOrderByWithRelationInput!], skip: Int, take: Int, where: ServiceWhereInput): [Service!]!
  tokens(cursor: TokenWhereUniqueInput, distinct: [TokenScalarFieldEnum!], orderBy: [TokenOrderByWithRelationInput!], skip: Int, take: Int, where: TokenWhereInput): [Token!]!
  updatedAt: DateTime!
}

type UserCount {
  requestsAsBarber: Int!
  requestsAsClient: Int!
  services: Int!
  tokens: Int!
}

type UserCountAggregate {
  _all: Int!
  createdAt: Int!
  email: Int!
  id: Int!
  name: Int!
  phone: Int!
  role: Int!
  updatedAt: Int!
}

input UserCountOrderByAggregateInput {
  createdAt: SortOrder
  email: SortOrder
  id: SortOrder
  name: SortOrder
  phone: SortOrder
  role: SortOrder
  updatedAt: SortOrder
}

input UserCreateInput {
  createdAt: DateTime
  email: String
  id: String
  name: String!
  phone: String
  requestsAsBarber: RequestCreateNestedManyWithoutBarberInput
  requestsAsClient: RequestCreateNestedManyWithoutClientInput
  role: Role!
  services: ServiceCreateNestedManyWithoutBarbersInput
  tokens: TokenCreateNestedManyWithoutUserInput
  updatedAt: DateTime
}

input UserCreateManyInput {
  createdAt: DateTime
  email: String
  id: String
  name: String!
  phone: String
  role: Role!
  updatedAt: DateTime
}

input UserCreateNestedManyWithoutServicesInput {
  connect: [UserWhereUniqueInput!]
  connectOrCreate: [UserCreateOrConnectWithoutServicesInput!]
  create: [UserCreateWithoutServicesInput!]
}

input UserCreateNestedOneWithoutRequestsAsBarberInput {
  connect: UserWhereUniqueInput
  connectOrCreate: UserCreateOrConnectWithoutRequestsAsBarberInput
  create: UserCreateWithoutRequestsAsBarberInput
}

input UserCreateNestedOneWithoutRequestsAsClientInput {
  connect: UserWhereUniqueInput
  connectOrCreate: UserCreateOrConnectWithoutRequestsAsClientInput
  create: UserCreateWithoutRequestsAsClientInput
}

input UserCreateNestedOneWithoutTokensInput {
  connect: UserWhereUniqueInput
  connectOrCreate: UserCreateOrConnectWithoutTokensInput
  create: UserCreateWithoutTokensInput
}

input UserCreateOrConnectWithoutRequestsAsBarberInput {
  create: UserCreateWithoutRequestsAsBarberInput!
  where: UserWhereUniqueInput!
}

input UserCreateOrConnectWithoutRequestsAsClientInput {
  create: UserCreateWithoutRequestsAsClientInput!
  where: UserWhereUniqueInput!
}

input UserCreateOrConnectWithoutServicesInput {
  create: UserCreateWithoutServicesInput!
  where: UserWhereUniqueInput!
}

input UserCreateOrConnectWithoutTokensInput {
  create: UserCreateWithoutTokensInput!
  where: UserWhereUniqueInput!
}

input UserCreateWithoutRequestsAsBarberInput {
  createdAt: DateTime
  email: String
  id: String
  name: String!
  phone: String
  requestsAsClient: RequestCreateNestedManyWithoutClientInput
  role: Role!
  services: ServiceCreateNestedManyWithoutBarbersInput
  tokens: TokenCreateNestedManyWithoutUserInput
  updatedAt: DateTime
}

input UserCreateWithoutRequestsAsClientInput {
  createdAt: DateTime
  email: String
  id: String
  name: String!
  phone: String
  requestsAsBarber: RequestCreateNestedManyWithoutBarberInput
  role: Role!
  services: ServiceCreateNestedManyWithoutBarbersInput
  tokens: TokenCreateNestedManyWithoutUserInput
  updatedAt: DateTime
}

input UserCreateWithoutServicesInput {
  createdAt: DateTime
  email: String
  id: String
  name: String!
  phone: String
  requestsAsBarber: RequestCreateNestedManyWithoutBarberInput
  requestsAsClient: RequestCreateNestedManyWithoutClientInput
  role: Role!
  tokens: TokenCreateNestedManyWithoutUserInput
  updatedAt: DateTime
}

input UserCreateWithoutTokensInput {
  createdAt: DateTime
  email: String
  id: String
  name: String!
  phone: String
  requestsAsBarber: RequestCreateNestedManyWithoutBarberInput
  requestsAsClient: RequestCreateNestedManyWithoutClientInput
  role: Role!
  services: ServiceCreateNestedManyWithoutBarbersInput
  updatedAt: DateTime
}

type UserGroupBy {
  _count: UserCountAggregate
  _max: UserMaxAggregate
  _min: UserMinAggregate
  createdAt: DateTime!
  email: String
  id: String!
  name: String!
  phone: String
  role: Role!
  updatedAt: DateTime!
}

input UserListRelationFilter {
  every: UserWhereInput
  none: UserWhereInput
  some: UserWhereInput
}

type UserMaxAggregate {
  createdAt: DateTime
  email: String
  id: String
  name: String
  phone: String
  role: Role
  updatedAt: DateTime
}

input UserMaxOrderByAggregateInput {
  createdAt: SortOrder
  email: SortOrder
  id: SortOrder
  name: SortOrder
  phone: SortOrder
  role: SortOrder
  updatedAt: SortOrder
}

type UserMinAggregate {
  createdAt: DateTime
  email: String
  id: String
  name: String
  phone: String
  role: Role
  updatedAt: DateTime
}

input UserMinOrderByAggregateInput {
  createdAt: SortOrder
  email: SortOrder
  id: SortOrder
  name: SortOrder
  phone: SortOrder
  role: SortOrder
  updatedAt: SortOrder
}

input UserOrderByRelationAggregateInput {
  _count: SortOrder
}

input UserOrderByWithAggregationInput {
  _count: UserCountOrderByAggregateInput
  _max: UserMaxOrderByAggregateInput
  _min: UserMinOrderByAggregateInput
  createdAt: SortOrder
  email: SortOrder
  id: SortOrder
  name: SortOrder
  phone: SortOrder
  role: SortOrder
  updatedAt: SortOrder
}

input UserOrderByWithRelationInput {
  createdAt: SortOrder
  email: SortOrder
  id: SortOrder
  name: SortOrder
  phone: SortOrder
  requestsAsBarber: RequestOrderByRelationAggregateInput
  requestsAsClient: RequestOrderByRelationAggregateInput
  role: SortOrder
  services: ServiceOrderByRelationAggregateInput
  tokens: TokenOrderByRelationAggregateInput
  updatedAt: SortOrder
}

input UserRelationFilter {
  is: UserWhereInput
  isNot: UserWhereInput
}

enum UserScalarFieldEnum {
  createdAt
  email
  id
  name
  phone
  role
  updatedAt
}

input UserScalarWhereInput {
  AND: [UserScalarWhereInput!]
  NOT: [UserScalarWhereInput!]
  OR: [UserScalarWhereInput!]
  createdAt: DateTimeFilter
  email: StringNullableFilter
  id: StringFilter
  name: StringFilter
  phone: StringNullableFilter
  role: EnumRoleFilter
  updatedAt: DateTimeFilter
}

input UserScalarWhereWithAggregatesInput {
  AND: [UserScalarWhereWithAggregatesInput!]
  NOT: [UserScalarWhereWithAggregatesInput!]
  OR: [UserScalarWhereWithAggregatesInput!]
  createdAt: DateTimeWithAggregatesFilter
  email: StringNullableWithAggregatesFilter
  id: StringWithAggregatesFilter
  name: StringWithAggregatesFilter
  phone: StringNullableWithAggregatesFilter
  role: EnumRoleWithAggregatesFilter
  updatedAt: DateTimeWithAggregatesFilter
}

input UserUpdateInput {
  createdAt: DateTimeFieldUpdateOperationsInput
  email: NullableStringFieldUpdateOperationsInput
  id: StringFieldUpdateOperationsInput
  name: StringFieldUpdateOperationsInput
  phone: NullableStringFieldUpdateOperationsInput
  requestsAsBarber: RequestUpdateManyWithoutBarberInput
  requestsAsClient: RequestUpdateManyWithoutClientInput
  role: EnumRoleFieldUpdateOperationsInput
  services: ServiceUpdateManyWithoutBarbersInput
  tokens: TokenUpdateManyWithoutUserInput
  updatedAt: DateTimeFieldUpdateOperationsInput
}

input UserUpdateManyMutationInput {
  createdAt: DateTimeFieldUpdateOperationsInput
  email: NullableStringFieldUpdateOperationsInput
  id: StringFieldUpdateOperationsInput
  name: StringFieldUpdateOperationsInput
  phone: NullableStringFieldUpdateOperationsInput
  role: EnumRoleFieldUpdateOperationsInput
  updatedAt: DateTimeFieldUpdateOperationsInput
}

input UserUpdateManyWithWhereWithoutServicesInput {
  data: UserUpdateManyMutationInput!
  where: UserScalarWhereInput!
}

input UserUpdateManyWithoutServicesInput {
  connect: [UserWhereUniqueInput!]
  connectOrCreate: [UserCreateOrConnectWithoutServicesInput!]
  create: [UserCreateWithoutServicesInput!]
  delete: [UserWhereUniqueInput!]
  deleteMany: [UserScalarWhereInput!]
  disconnect: [UserWhereUniqueInput!]
  set: [UserWhereUniqueInput!]
  update: [UserUpdateWithWhereUniqueWithoutServicesInput!]
  updateMany: [UserUpdateManyWithWhereWithoutServicesInput!]
  upsert: [UserUpsertWithWhereUniqueWithoutServicesInput!]
}

input UserUpdateOneRequiredWithoutRequestsAsBarberInput {
  connect: UserWhereUniqueInput
  connectOrCreate: UserCreateOrConnectWithoutRequestsAsBarberInput
  create: UserCreateWithoutRequestsAsBarberInput
  update: UserUpdateWithoutRequestsAsBarberInput
  upsert: UserUpsertWithoutRequestsAsBarberInput
}

input UserUpdateOneRequiredWithoutRequestsAsClientInput {
  connect: UserWhereUniqueInput
  connectOrCreate: UserCreateOrConnectWithoutRequestsAsClientInput
  create: UserCreateWithoutRequestsAsClientInput
  update: UserUpdateWithoutRequestsAsClientInput
  upsert: UserUpsertWithoutRequestsAsClientInput
}

input UserUpdateOneRequiredWithoutTokensInput {
  connect: UserWhereUniqueInput
  connectOrCreate: UserCreateOrConnectWithoutTokensInput
  create: UserCreateWithoutTokensInput
  update: UserUpdateWithoutTokensInput
  upsert: UserUpsertWithoutTokensInput
}

input UserUpdateWithWhereUniqueWithoutServicesInput {
  data: UserUpdateWithoutServicesInput!
  where: UserWhereUniqueInput!
}

input UserUpdateWithoutRequestsAsBarberInput {
  createdAt: DateTimeFieldUpdateOperationsInput
  email: NullableStringFieldUpdateOperationsInput
  id: StringFieldUpdateOperationsInput
  name: StringFieldUpdateOperationsInput
  phone: NullableStringFieldUpdateOperationsInput
  requestsAsClient: RequestUpdateManyWithoutClientInput
  role: EnumRoleFieldUpdateOperationsInput
  services: ServiceUpdateManyWithoutBarbersInput
  tokens: TokenUpdateManyWithoutUserInput
  updatedAt: DateTimeFieldUpdateOperationsInput
}

input UserUpdateWithoutRequestsAsClientInput {
  createdAt: DateTimeFieldUpdateOperationsInput
  email: NullableStringFieldUpdateOperationsInput
  id: StringFieldUpdateOperationsInput
  name: StringFieldUpdateOperationsInput
  phone: NullableStringFieldUpdateOperationsInput
  requestsAsBarber: RequestUpdateManyWithoutBarberInput
  role: EnumRoleFieldUpdateOperationsInput
  services: ServiceUpdateManyWithoutBarbersInput
  tokens: TokenUpdateManyWithoutUserInput
  updatedAt: DateTimeFieldUpdateOperationsInput
}

input UserUpdateWithoutServicesInput {
  createdAt: DateTimeFieldUpdateOperationsInput
  email: NullableStringFieldUpdateOperationsInput
  id: StringFieldUpdateOperationsInput
  name: StringFieldUpdateOperationsInput
  phone: NullableStringFieldUpdateOperationsInput
  requestsAsBarber: RequestUpdateManyWithoutBarberInput
  requestsAsClient: RequestUpdateManyWithoutClientInput
  role: EnumRoleFieldUpdateOperationsInput
  tokens: TokenUpdateManyWithoutUserInput
  updatedAt: DateTimeFieldUpdateOperationsInput
}

input UserUpdateWithoutTokensInput {
  createdAt: DateTimeFieldUpdateOperationsInput
  email: NullableStringFieldUpdateOperationsInput
  id: StringFieldUpdateOperationsInput
  name: StringFieldUpdateOperationsInput
  phone: NullableStringFieldUpdateOperationsInput
  requestsAsBarber: RequestUpdateManyWithoutBarberInput
  requestsAsClient: RequestUpdateManyWithoutClientInput
  role: EnumRoleFieldUpdateOperationsInput
  services: ServiceUpdateManyWithoutBarbersInput
  updatedAt: DateTimeFieldUpdateOperationsInput
}

input UserUpsertWithWhereUniqueWithoutServicesInput {
  create: UserCreateWithoutServicesInput!
  update: UserUpdateWithoutServicesInput!
  where: UserWhereUniqueInput!
}

input UserUpsertWithoutRequestsAsBarberInput {
  create: UserCreateWithoutRequestsAsBarberInput!
  update: UserUpdateWithoutRequestsAsBarberInput!
}

input UserUpsertWithoutRequestsAsClientInput {
  create: UserCreateWithoutRequestsAsClientInput!
  update: UserUpdateWithoutRequestsAsClientInput!
}

input UserUpsertWithoutTokensInput {
  create: UserCreateWithoutTokensInput!
  update: UserUpdateWithoutTokensInput!
}

input UserWhereInput {
  AND: [UserWhereInput!]
  NOT: [UserWhereInput!]
  OR: [UserWhereInput!]
  createdAt: DateTimeFilter
  email: StringNullableFilter
  id: StringFilter
  name: StringFilter
  phone: StringNullableFilter
  requestsAsBarber: RequestListRelationFilter
  requestsAsClient: RequestListRelationFilter
  role: EnumRoleFilter
  services: ServiceListRelationFilter
  tokens: TokenListRelationFilter
  updatedAt: DateTimeFilter
}

input UserWhereUniqueInput {
  email: String
  id: String
}
